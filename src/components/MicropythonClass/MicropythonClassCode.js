export const class1MCode = [
    `from machine import Pin`,
    `from machine import Pin\nimport time`,
    `from machine import Pin\nimport time\nprint("Led encendido")`,
    `from machine import Pin\nimport time\nprint("Led encendido")\nPin("LED",Pin.OUT).value(1)`,
    `from machine import Pin\nimport time\nprint("Led encendido")\nPin("LED",Pin.OUT).value(1)\ntime.sleep(2)`,
    `from machine import Pin\nimport time\nprint("Led encendido")\nPin("LED",Pin.OUT).value(1)\ntime.sleep(2)\nprint("Led apagado")\nPin("LED",pin.OUT).value(0)`,
    `from machine import Pin\nimport time\nprint("Led encendido")\nPin("LED",Pin.OUT).value(1)\ntime.sleep(2)\nprint("Led apagado")\nPin("LED",pin.OUT).value(0)\ntime.sleep(2)\nprint("Led encendido")\nPin("LED",Pin.OUT).value(1)\ntime.sleep(2)\nprint("Led apagado")\nPin("LED",pin.OUT).value(0)`
]

export const class2MCode = [
    `print("hola")`,
    `led = int(input("1_ Activar led 2_ Desactivar Led   "))\nprint(led)`,
    `from machine import Pin\nled = int(input("1_ Activar led 2_ Desactivar Led "))\nprint(led)\n\nif led ==1:\n    Pin("LED",Pin.OUT).value(1)\nelif led == 2:\n    Pin("LED",Pin.OUT).value(0)`
   ]

export const class3MCode = [
    `from machine import Pin\nimport utime\nboton = Pin(3,Pin.IN,Pin.PULL_UP)\nwhile True:\n    print(boton.value())\n    utime.sleep(2)`,
    `from machine import Pin\nfrom time import sleep\n\nboton = Pin(5, Pin.IN, Pin.PULL_DOWN)\n\nwhile True:\n    if boton.value():\n        print("Botón presionado")\n    else:\n        print("Botón no presionado")\n\n    sleep(1) `,
    `from machine import Pin\nimport time\n\nled = Pin(15, Pin.OUT)  # Configura el GPIO 15 como salida\n\nwhile True:\n    led.on()  # Enciende el LED\n    time.sleep(1)  # Espera 1 segundo\n    led.off()  # Apaga el LED\n    time.sleep(1)  # Espera 1 segundo`,
    `import machine\nimport time\n\nbutton = machine.Pin(6, machine.Pin.IN, machine.Pin.PULL_UP)\nled= machine.Pin(22, machine.Pin.OUT)\n\nwhile True:\n    print("estado:", button.value())\n    if(button.value()== 0):\n        led.value(1)\n        time.sleep(0.1)\n    else:\n        led.value(0)`,
    `from machine import Pin\nfrom utime import sleep\n\nled_red = Pin(6, Pin.OUT)\nled_green = Pin(5, Pin.OUT)\nled_blue = Pin(4, Pin.OUT)\n\nwhile True:\n    led_red.value(1)\n    sleep(1)\n    led_red.value(0)\n    led_green.value(1)\n    sleep(1)\n    led_green.value(0)\n    led_blue.value(1)\n    sleep(1)\n    led_blue.value(0)\n`,
    `from machine import Pin\nfrom utime import sleep\n\nled_red = Pin(6, Pin.OUT)\nled_green = Pin(5, Pin.OUT)\nled_blue = Pin(4, Pin.OUT)\n\nbutton1 = machine.Pin(7, machine.Pin.IN, machine.Pin.PULL_UP)\nbutton2 = machine.Pin(10, machine.Pin.IN, machine.Pin.PULL_UP)\nbutton3 = machine.Pin(13, machine.Pin.IN, machine.Pin.PULL_UP)\n\nwhile True:\n    if(button1.value()== 0):\n        led_blue.value(1)\n        sleep(1)\n        led_blue.value(0)\n\n    elif(button2.value()== 0):\n        led_green.value(1)\n        sleep(1)\n        led_green.value(0)\n\n        elif(button3.value()== 0):\n        led_red.value(1)\n        sleep(1)\n        led_red.value(0)\n\n    else:\n        led_blue.value(0)\n        led_green.value(0)\n        led_red.value(0)`
] 

export const class4MCode = [
    `from machine import Pin, ADC # Importación de ADC\nfrom time import sleep`,
    `from machine import Pin, ADC # Importación de ADC\nfrom time import sleep\n\n# crea el objeto ADC para manipular el potenciometro.\nadc = ADC(Pin(28))\n# Nota: los pins GPIO que soportan ADC son solamente los Pin 26-28\n`,
    `from machine import Pin, ADC # Importación de ADC\nfrom time import sleep\n\n# crea el objeto ADC para manipular el potenciometro.\nadc = ADC(Pin(28))\n# Nota: los pins GPIO que soportan ADC son solamente los Pin 26-28\n\nwhile True:\n    # lectura de valor análogo desde el potenciometro\n    analog_value = adc.read_u16()\n    print(f"Valor análogo(duty cycle): {analog_value}")\n\n    # Valor de voltaje desde el potenciometro\n    voltage = analog_value * (3.3 / 65535)\n    print(f"Voltage: {voltage}")\n\n    print("==========")\n    sleep(1)`,
    `from machine import Pin, ADC, PWM # Importación de ADC\nfrom time import sleep\n\n# crea el objeto ADC para manipular el potenciometro.\nadc = ADC(Pin(28))\n\nwhile True:\n    # lectura de valor análogo desde el potenciometro\n    analog_value = adc.read_u16()\n    print(f"Valor análogo(duty cycle): {analog_value}")\n\n    # Valor de voltaje desde el potenciometro\n    voltage = analog_value * (3.3 / 65535)\n    print(f"Voltage: {voltage}")\n\n    print("==========")\n    sleep(1)`,
    `from machine import Pin, ADC, PWM # Importación de ADC\nfrom time import sleep\n\n# crea el objeto ADC para manipular el potenciometro.\nadc = ADC(Pin(28))\n\n# Crear objeto PWM en un pin específico\npwm = PWM(Pin(15)) # Pin 15 para salida de PWM\n\n# Establecer la frecuencia a 1KHz (1000Hz)\npwm.freq(1000)\n\nwhile True:\n    # lectura de valor análogo desde el potenciometro\n    analog_value = adc.read_u16()\n    print(f"Valor análogo(duty cycle): {analog_value}")\n\n    # Valor de voltaje desde el potenciometro\n    voltage = analog_value * (3.3 / 65535)\n    print(f"Voltage: {voltage}")\n\n    print("==========")\n    sleep(1)`,
    `from machine import Pin, ADC, PWM   # Importación de ADC Y PWM\nfrom time import sleep\n\n# Crea el objeto ADC para manipular el potenciometro\nadc = ADC(Pin(28))\n\npwm = PWM(Pin(15)) # Pin 15 para salida de PWM\n# Establecer la frecuencia a 1KHz (1000Hz)\npwm.freq(1000)\n\nwhile True:\n    analog_value = adc.read_u16()\n    print(f"Analog value: {analog_value}")\n    pwm.duty_u16(analog_value)  # valor de intensidad de led\n\n    voltage = analog_value * (3.3 / 65535)\n    print(f"Voltage: {voltage}")\n\n    print(f"Frecuencia: {pwm.freq()} Hz")\n    print("==========")\n    sleep(1)\n`,
    `from machine import Pin, ADC\nfrom time import sleep\nadc = ADC(Pin(28))\nled1 = Pin(6, Pin.OUT)\nled2 = Pin(7, Pin.OUT)\nled3 = Pin(8, Pin.OUT)\nled4 = Pin(9, Pin.OUT)\nwhile True:\n analog_value = adc.read_u16() / 65535\n print(analog_value)\n led1.off(); led2.off(); led3.off(); led4.off()\n if analog_value > 0.25: led1.on()\n if analog_value > 0.50: led2.on()\n if analog_value > 0.75: led3.on()\n if analog_value > 0.90: led4.on()\n sleep(0.1)`,
    `from machine import Pin, ADC\nfrom time import sleep\nadc = ADC(Pin(28))\nled1 = Pin(6, Pin.OUT)\nled2 = Pin(7, Pin.OUT)\nled3 = Pin(8, Pin.OUT)\nwhile True:\n    analog_value = adc.read_u16() / 65535\n    print(analog_value)\n    led1.off()\n    led2.off()\n    led3.off()\n    if analog_value <= 0.33:\n        led1.on()\n        led1.off()\n        led1.off()\n    elif analog_value > 0.66:\n        led3.on()\n        led3.off()\n        led3.off()\n    else:\n        led2.on()\n    sleep(0.1)`,
    `from machine import Pin, ADC\nfrom time import sleep\nadc = ADC(Pin(28))\nLEDS = [Pin(LED, Pin.OUT) for LED in range(6, 9)]\nwhile True:\n    analog_value = adc.read_u16() / 65535\n    print(analog_value)\n    for i in range(3):\n        LEDS[i].off()\n    if analog_value <= 0.33:\n        LEDS[0].on()\n    elif analog_value > 0.66:\n        LEDS[2].on()\n    else:\n        LEDS[1].on()\n    sleep(0.1)`,
    `from machine import Pin, ADC, PWM\nfrom time import sleep\nadc = ADC(Pin(28))\npwm = PWM(Pin(15))\npwm.freq(50)\nwhile True:\n    pot = int(adc.read_u16() * 180 / 65535)\n    print(f"{pot}°")\n    ton = (pot + 45) * 100000 / 9\n    print(ton)\n    pwm.duty_ns(int(ton))`
] 

export const class5MCode = [
`import network`,
`import network\n\n# Inicializa la interfaz de red en modo estación\nwlan = network.WLAN(network.STA_IF)\nwlan.active(True)\n`,
`import network\n\n# Inicializa la interfaz de red en modo estación\nwlan = network.WLAN(network.STA_IF)\nwlan.active(True)\n\n# Escanea las redes Wi-Fi disponibles\nprint("Escaneando redes Wi-Fi...")\nnetworks = wlan.scan()\n`,
`import network\n\n# Inicializa la interfaz de red en modo estación\nwlan = network.WLAN(network.STA_IF)\nwlan.active(True)\n\n# Escanea las redes Wi-Fi disponibles\nprint("Escaneando redes Wi-Fi...")\nnetworks = wlan.scan()\n\n# Muestra las redes encontradas\n# usamos *_ para omitir datos que no nos interesa de la tupla\nfor ssid, *_ in networks:\n    # Decodifica el SSID de bytes a cadena\n    print("Red encontrada:", ssid.decode('utf-8'))\n\n    # Desactiva la interfaz después del escaneo\nwlan.active(False)\n`
]

export const class6MCode = [
    `import time\nclass LcdApi:\n    # Implements the API for talking with HD44780 compatible character LCDs.\n    # This class only knows what commands to send to the LCD, and not how to get\n    # them to the LCD.\n    #\n    # It is expected that a derived class will implement the hal_xxx functions.\n    #\n    # The following constant names were lifted from the avrlib lcd.h header file,\n    # with bit numbers changed to bit masks.\n    #\n    # HD44780 LCD controller command set\n    LCD_CLR = 0x01\n    LCD_HOME = 0x02\n    LCD_ENTRY_MODE = 0x04\n    LCD_ENTRY_INC = 0x02\n    LCD_ENTRY_SHIFT = 0x01\n    LCD_ON_CTRL = 0x08\n    LCD_ON_DISPLAY = 0x04\n    LCD_ON_CURSOR = 0x02\n    LCD_ON_BLINK = 0x01\n    LCD_MOVE = 0x10\n    LCD_MOVE_DISP = 0x08\n    LCD_MOVE_RIGHT = 0x04\n    LCD_FUNCTION = 0x20\n    LCD_FUNCTION_8BIT = 0x10\n    LCD_FUNCTION_2LINES = 0x08\n    LCD_FUNCTION_10DOTS = 0x04\n    LCD_FUNCTION_RESET = 0x30\n    LCD_CGRAM = 0x40\n    LCD_DDRAM = 0x80\n    LCD_RS_CMD = 0\n    LCD_RS_DATA = 1\n    LCD_RW_WRITE = 0\n    LCD_RW_READ = 1\n\n    def __init__(self, num_lines, num_columns):\n        self.num_lines = num_lines\n        if self.num_lines > 4:\n            self.num_lines = 4\n        self.num_columns = num_columns\n        if self.num_columns > 40:\n            self.num_columns = 40\n        self.cursor_x = 0\n        self.cursor_y = 0\n        self.implied_newline = False\n        self.backlight = True\n        self.display_off()\n        self.backlight_on()\n        self.clear()\n        self.hal_write_command(self.LCD_ENTRY_MODE | self.LCD_ENTRY_INC)\n        self.hide_cursor()\n        self.display_on()\n\n    def clear(self):\n        self.hal_write_command(self.LCD_CLR)\n        self.hal_write_command(self.LCD_HOME)\n        self.cursor_x = 0\n        self.cursor_y = 0\n\n    def show_cursor(self):\n        self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY | self.LCD_ON_CURSOR)\n\n    def hide_cursor(self):\n        self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY)\n\n    def blink_cursor_on(self):\n        self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY | self.LCD_ON_CURSOR | self.LCD_ON_BLINK)\n\n    def blink_cursor_off(self):\n        self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY | self.LCD_ON_CURSOR)\n\n    def display_on(self):\n        self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY)\n\n    def display_off(self):\n        self.hal_write_command(self.LCD_ON_CTRL)\n\n    def backlight_on(self):\n        self.backlight = True\n        self.hal_backlight_on()\n\n    def backlight_off(self):\n        self.backlight = False\n        self.hal_backlight_off()\n\n    def move_to(self, cursor_x, cursor_y):\n        self.cursor_x = cursor_x\n        self.cursor_y = cursor_y\n        addr = cursor_x & 0x3f\n        if cursor_y & 1:\n            addr += 0x40\n        if cursor_y & 2:\n            addr += self.num_columns\n        self.hal_write_command(self.LCD_DDRAM | addr)\n\n    def putchar(self, char):\n        if char == '\\n':\n            if self.implied_newline:\n                pass\n            else:\n                self.cursor_x = self.num_columns\n        else:\n            self.hal_write_data(ord(char))\n            self.cursor_x += 1\n        if self.cursor_x >= self.num_columns:\n            self.cursor_x = 0\n            self.cursor_y += 1\n            self.implied_newline = (char != '\\n')\n        if self.cursor_y >= self.num_lines:\n            self.cursor_y = 0\n        self.move_to(self.cursor_x, self.cursor_y)\n\n    def putstr(self, string):\n        for char in string:\n            self.putchar(char)\n\n    def custom_char(self, location, charmap):\n        location &= 0x7\n        self.hal_write_command(self.LCD_CGRAM | (location << 3))\n        self.hal_sleep_us(40)\n        for i in range(8):\n            self.hal_write_data(charmap[i])\n            self.hal_sleep_us(40)\n        self.move_to(self.cursor_x, self.cursor_y)\n\n    def hal_backlight_on(self):\n        pass\n\n    def hal_backlight_off(self):\n        pass\n\n    def hal_write_command(self, cmd):\n        raise NotImplementedError\n\n    def hal_write_data(self, data):\n        raise NotImplementedError\n\n    def hal_sleep_us(self, usecs):\n        time.sleep_us(usecs)`,
    `import utime\nimport gc\nfrom lcd_api import LcdApi\nfrom machine import I2C\n# PCF8574 pin definitions\nMASK_RS = 0x01\nMASK_RW = 0x02\nMASK_E  = 0x04\nSHIFT_BACKLIGHT = 3\nSHIFT_DATA      = 4\nclass I2cLcd(LcdApi):\n    #Implements a HD44780 character LCD connected via PCF8574 on I2C\n\n    def __init__(self, i2c, i2c_addr, num_lines, num_columns):\n        self.i2c = i2c\n        self.i2c_addr = i2c_addr\n        self.i2c.writeto(self.i2c_addr, bytes([0]))\n        utime.sleep_ms(20)\n        self.hal_write_init_nibble(self.LCD_FUNCTION_RESET)\n        utime.sleep_ms(5)\n        self.hal_write_init_nibble(self.LCD_FUNCTION_RESET)\n        utime.sleep_ms(1)\n        self.hal_write_init_nibble(self.LCD_FUNCTION_RESET)\n        utime.sleep_ms(1)\n        self.hal_write_init_nibble(self.LCD_FUNCTION)\n        utime.sleep_ms(1)\n        LcdApi.__init__(self, num_lines, num_columns)\n        cmd = self.LCD_FUNCTION\n        if num_lines > 1:\n            cmd |= self.LCD_FUNCTION_2LINES\n        self.hal_write_command(cmd)\n        gc.collect()\n\n    def hal_write_init_nibble(self, nibble):\n        byte = ((nibble >> 4) & 0x0f) << SHIFT_DATA\n        self.i2c.writeto(self.i2c_addr, bytes([byte | MASK_E]))\n        self.i2c.writeto(self.i2c_addr, bytes([byte]))\n        gc.collect()\n\n    def hal_backlight_on(self):\n        self.i2c.writeto(self.i2c_addr, bytes([1 << SHIFT_BACKLIGHT]))\n        gc.collect()\n\n    def hal_backlight_off(self):\n        self.i2c.writeto(self.i2c_addr, bytes([0]))\n        gc.collect()\n\n    def hal_write_command(self, cmd):\n        byte = ((self.backlight << SHIFT_BACKLIGHT) | (((cmd >> 4) & 0x0f) << SHIFT_DATA))\n        self.i2c.writeto(self.i2c_addr, bytes([byte | MASK_E]))\n        self.i2c.writeto(self.i2c_addr, bytes([byte]))\n        byte = ((self.backlight << SHIFT_BACKLIGHT) | ((cmd & 0x0f) << SHIFT_DATA))\n        self.i2c.writeto(self.i2c_addr, bytes([byte | MASK_E]))\n        self.i2c.writeto(self.i2c_addr, bytes([byte]))\n        if cmd <= 3:\n            utime.sleep_ms(5)\n        gc.collect()\n\n    def hal_write_data(self, data):\n        byte = (MASK_RS | (self.backlight << SHIFT_BACKLIGHT) | (((data >> 4) & 0x0f) << SHIFT_DATA))\n        self.i2c.writeto(self.i2c_addr, bytes([byte | MASK_E]))\n        self.i2c.writeto(self.i2c_addr, bytes([byte]))\n        byte = (MASK_RS | (self.backlight << SHIFT_BACKLIGHT) | ((data & 0x0f) << SHIFT_DATA))\n        self.i2c.writeto(self.i2c_addr, bytes([byte | MASK_E]))\n        self.i2c.writeto(self.i2c_addr, bytes([byte]))\n        gc.collect()`,
    `from pico_i2c_lcd import I2cLcd`,
    `from machine import Pin, I2C\nfrom time import sleep\nfrom pico_i2c_lcd import I2cLcd`,
    `from machine import Pin, I2C\nfrom time import sleep\nfrom pico_i2c_lcd import I2cLcd\n\ni2c=I2C(0,sda=Pin(0), scl=Pin(1), freq=400000)`,
    `from machine import Pin, I2C\nfrom time import sleep\nfrom pico_i2c_lcd import I2cLcd\n\ni2c=I2C(0,sda=Pin(0), scl=Pin(1), freq=400000)\n\nI2C_ADDR=i2c.scan()[0]`,
    `from machine import Pin, I2C\nfrom time import sleep\nfrom pico_i2c_lcd import I2cLcd\n\ni2c=I2C(0,sda=Pin(0), scl=Pin(1), freq=400000)\n\nI2C_ADDR=i2c.scan()[0]\n\n#crear objeto tipo lcd\nlcd=I2cLcd(i2c,I2C_ADDR,2,16)`   ,
    `from machine import Pin, I2C\nfrom time import sleep\nfrom pico_i2c_lcd import I2cLcd\n\ni2c=I2C(0,sda=Pin(0), scl=Pin(1), freq=400000)\n\nI2C_ADDR=i2c.scan()[0]\n\n#crear objeto tipo lcd\nlcd=I2cLcd(i2c,I2C_ADDR,2,16)\n\nwhile True:\n    lcd.putstr("Micropython")\n    sleep(5)\n    lcd.clear()`   
]